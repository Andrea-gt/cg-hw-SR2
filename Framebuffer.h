#ifndef FRAMEBUFFER_H
#define FRAMEBUFFER_H

#include <array>
#include <glm/vec3.hpp>
#include <math.h>
#include <omp.h>
#include "Color.h" // Include your Color class header
#include "Fragment.h"
#include "Line.h"

constexpr size_t SCREEN_WIDTH = 1000;
constexpr size_t SCREEN_HEIGHT = 700;


// Create a framebuffer alias using the Color struct and the defined screen dimensions
using Framebuffer = std::array<std::array<Color, SCREEN_WIDTH>, SCREEN_HEIGHT>;

void clear(Framebuffer& framebuffer) {

#pragma omp parallel for
    for (size_t i = 0; i < SCREEN_HEIGHT; i++) {
        for (size_t j = 0; j < SCREEN_WIDTH; j++) {
            framebuffer[i][j] = Color(0,0,0);
        }
    }
}

void point(Framebuffer &framebuffer, int x, int y, Color color) {
    int centeredX = x + SCREEN_WIDTH/2;
    int centeredY = y + SCREEN_HEIGHT/2;
    if (centeredX >= 0 && centeredX < SCREEN_WIDTH && centeredY >= 0 && centeredY < SCREEN_HEIGHT) {
        framebuffer[centeredY][centeredX] = color;
    }
}

std::vector<Fragment>  triangle(const glm::vec3& A, const glm::vec3& B, const glm::vec3& C) {
    std::vector<Fragment> triangleFragments;

    // Insert the fragments generated by line(A, B) into triangleFragments
    std::vector<Fragment> fragmentsAB = line(A, B);
    triangleFragments.insert(triangleFragments.end(), fragmentsAB.begin(), fragmentsAB.end());

    // Insert the fragments generated by line(B, C) into triangleFragments
    std::vector<Fragment> fragmentsBC = line(B, C);
    triangleFragments.insert(triangleFragments.end(), fragmentsBC.begin(), fragmentsBC.end());

    // Insert the fragments generated by line(A, C) into triangleFragments
    std::vector<Fragment> fragmentsCA = line(A, C);
    triangleFragments.insert(triangleFragments.end(), fragmentsCA.begin(), fragmentsCA.end());

    return triangleFragments;
}

void renderBuffer(SDL_Renderer* renderer, const Framebuffer& framebuffer, int textureWidth, int textureHeight) {
    SDL_Texture* texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, textureWidth, textureHeight);

    void* texturePixels;
    int pitch;
    SDL_LockTexture(texture, NULL, &texturePixels, &pitch);

    Uint32 format = SDL_PIXELFORMAT_ARGB8888;
    SDL_PixelFormat* mappingFormat = SDL_AllocFormat(format);

    Uint32* texturePixels32 = static_cast<Uint32*>(texturePixels);

#pragma omp parallel for
    for (int y = 0; y < textureHeight; y++) {
        for (int x = 0; x < textureWidth; x++) {
            int index = y * (pitch / sizeof(Uint32)) + x;
            const Color& color = framebuffer[y][x];
            texturePixels32[index] = SDL_MapRGBA(mappingFormat, color.r, color.g, color.b, color.a);
        }
    }

    SDL_UnlockTexture(texture);
    SDL_Rect textureRect = {0, 0, textureWidth, textureHeight};
    SDL_RenderCopy(renderer, texture, NULL, &textureRect);
    SDL_DestroyTexture(texture);

    SDL_RenderPresent(renderer);
}

#endif // FRAMEBUFFER_H